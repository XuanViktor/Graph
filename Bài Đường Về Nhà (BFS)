B. Đường về nhà
Vana đang trên đường bắt xe bus từ Hà Nội về nhà, các trạm bus trên đường đi được đánh số từ 1 đến n
. Nhà của Vana ở điểm bus thứ n và bây giờ Vana sẽ xuất phát từ điểm 1
. Đường đi này của Vana có một chút đặc biệt, Vana có thể di chuyển sang một điểm ở bên phải nếu khoảng cách giữa hai điểm không quá d
. Điều đó có nghĩa là nếu đang ở điểm x Vana có thể di chuyển đến x+a , với a là một số nguyên từ 1 đến d
. Được biết với mỗi điểm từ 1 đến n có thể có một bông hoa Mely ở đó. Vana chỉ thích đi qua những điểm có hoa Mely thôi nên điểm nào không có hoa Mel thì Vana không đi đâu. 
. Giả thiết đảm bảo rằng có hoa Mely ở điểm 1 và n
. Xác định số điểm nhỏ nhất mà Vana cần đi qua để về nhà tại điểm n với điểm xuất phát là điểm 1
. Nếu Vana không thể về nhà in ra-1.

Input
 Dòng đầu tiên gồm 2 số nguyên n và d
 2≤n≤100, 1≤d≤n−1) — điểm bus tới nhà Vana và khoảng cách tối đa Vana có thể di chuyển giữa hai điểm bus.
 Dòng thứ hai chứa xâu s độ dài n, chỉ chứa 0 và 1. 
 Nếu kí tự thứ itrong xâu s là 0 tương đương với việc điểm đó không có hoa Mely ngược lại nếu là 1 thì điểm đó có hoa Mely
 Giả thiết đảm bảo rằng kí tự đầu tiên và cuối cùng của s là 1.

Output
 Nếu Vana không thể về nhà in ra -1.
 Trường hợp còn lại in ra số điểm nhỏ nhất Vana cần qua để có thể về được nhà tại điểm n
 khi xuất phát tại điểm 1

Examples
inputCopy
9 3
101101101
outputCopy
3
inputCopy
5 1
10101
outputCopy
-1

Note
Trong ví dụ thứ nhất Vana có thể về nhà với 3 điểm bus cần đi qua: lần 1 đi từ 1
 tới 4 (khoảng cách giữa hai điểm là 3), và lần thứ hai từ 4
 đến 7 (khoảng cách giữa hai điểm là 3), lần thứ 3 đi từ điểm 7
 đến 9 (khoảng cách giữa hai điểm là 2).

Trong ví dụ thứ 2 Vana không thể về được nhà bởi vì các điểm bus có hoa Mely
trên đường về nhà đều có khoảng cách là 2 mà khoảng cách tối đa Vana có thể di chuyển được là 1.


#include <bits/stdc++.h>
using namespace std;

const int MAXN = 101;
const int INF = 1e9;

int n, d;
string s;

int bfs() {
    vector<int> distance(n, INF); // Tạo một mảng để lưu trữ khoảng cách từ điểm bắt đầu đến các điểm khác, khởi tạo tất cả là vô cùng (INF).
    queue<int> q; // Tạo một hàng đợi để thực hiện BFS.

    q.push(0); // Bắt đầu tại vị trí 0 (điểm bắt đầu).
    distance[0] = 0; // Khoảng cách từ điểm bắt đầu đến chính nó là 0.

    while (!q.empty()) { // Bắt đầu vòng lặp BFS cho đến khi hàng đợi trống.
        int current = q.front(); // Lấy ra phần tử đầu tiên trong hàng đợi.
        q.pop(); // Loại bỏ phần tử vừa lấy ra.

        if (current == n - 1) { // Nếu đã đến điểm cuối (n-1) thì trả về khoảng cách hiện tại.
            return distance[current];
        }

        for (int i = 1; i <= d; i++) { // Duyệt qua các bước có thể đi từ điểm hiện tại.
            int next = current + i; // Tính vị trí tiếp theo.
            if (next < n && s[next] == '1' && distance[next] == INF) { // Kiểm tra xem có thể đi đến điểm tiếp theo hay không, và nếu khoảng cách chưa được cập nhật.
                q.push(next); // Đưa điểm tiếp theo vào hàng đợi.
                distance[next] = distance[current] + 1; // Cập nhật khoảng cách đến điểm tiếp theo.
            }
        }
    }

    return -1; // Nếu không thể đến được điểm cuối, trả về -1.
}

int main() {
    cin >> n >> d; // Nhập số điểm và khoảng cách tối đa có thể đi qua.
    cin >> s; // Nhập chuỗi mô tả vị trí của hoa Mely.

    int result = bfs(); // Gọi hàm BFS để tìm số điểm nhỏ nhất cần đi qua.
    cout << result << endl; // In ra kết quả.

    return 0;
}

// 9 3
// 101101101

// Tương đương 
// 9 8
// 1 2
// 1 3
// 3 4
// 3 6
// 4 6
// 4 7
// 6 7 
// 6 9
